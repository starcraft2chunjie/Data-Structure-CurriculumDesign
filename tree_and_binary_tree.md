# 树与二叉树

## 树的存储结构
### 双亲表示法

### 孩子表示法


## 从树到二叉树的转换
基于左孩右树的原则
二叉树可以表示一个树当他的右子树为空。

## 树遍历
存在先根遍历和后根遍历

树的先根和后根遍历，分别与其对应的二叉树的前序和中序遍历的结果一致。

## 树的长度

树T的根到树中每一个叶子的路径乘以到每一个叶子的权值的和。
在相同的叶子树与相同的权重的情况下，寻找最少的值的二叉树。

### 赫夫曼算法

* 每个叶子与权值作为一个只含根的二叉树，形成森林
* 选出两个权值最小的，合并根为左右孩子的权值之和
* 重复2，其中合并的根与前面分散的看做同一等级，合并时根植依然为左右孩子之和
* 完成操作

### 赫夫曼编码：
字符出现频率高的给短码，频率低的给长码，且频率高的短码不能是长码的前缀。
使用赫夫曼算法
构造最短二叉树，保证了平均耗费最少，其中叶节点权值为每个出现的概率，则也可以保证短码不是长码的前缀。

### 存储结构（方案一）
（1）先存叶节点，初始化其权重，初始化其父母，左孩子，右孩子均为0
（2）遍历叶节点的权重，找出最小的，加起来放在下一个存储点，更新各个值。以此类推。
（3）遍历时从叶节点开始，结果为逆序，构造栈使其正序

### 存储结构（方案二）
将节点从小到大用链表排序，讲最小的两个节点指向新的节点，更新左右节点，新节点更新权重，并找到合适的位置进行插入，继续下一步。

